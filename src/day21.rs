use std::collections::HashMap;

/*
+---+---+---+
| 7 | 8 | 9 |
+---+---+---+
| 4 | 5 | 6 |
+---+---+---+
| 1 | 2 | 3 |
+---+---+---+
    | 0 | A |
    +---+---+

*/
const NUMERIC_KEYPAD: [(char, (i32, i32)); 11] = [
    ('A', (2, 3)),
    ('0', (1, 3)),
    ('1', (0, 2)),
    ('2', (1, 2)),
    ('3', (2, 2)),
    ('4', (0, 1)),
    ('5', (1, 1)),
    ('6', (2, 1)),
    ('7', (0, 0)),
    ('8', (1, 0)),
    ('9', (2, 0)),
];

/*
    +---+---+
    | ^ | A |
+---+---+---+
| < | v | > |
+---+---+---+
*/
const DIRECTIONAL_KEYPAD: [(char, (i32, i32)); 5] = [
    ('A', (2, 0)),
    ('^', (1, 0)),
    ('<', (0, 1)),
    ('v', (0, 2)),
    ('>', (0, 3)),
];

type Rule = HashMap<(char, char), Vec<&'static str>>;

fn directional_keypad_rule() -> Rule {
    HashMap::from([
        (('A', '^'), vec!["<"]),
        (('A', '<'), vec!["v<<"]),
        (('A', 'v'), vec!["v<", "<v"]),
        (('A', '>'), vec!["v"]),
        //
        (('^', 'A'), vec![">"]),
        (('^', '<'), vec!["v<"]),
        (('^', 'v'), vec!["v"]),
        (('^', '>'), vec!["v>", ">v"]),
        //
        (('<', 'A'), vec![">>^"]),
        (('<', '^'), vec![">^"]),
        (('<', 'v'), vec![">"]),
        (('<', '>'), vec![">>"]),
        //
        (('v', 'A'), vec!["^>", ">^"]),
        (('v', '^'), vec!["^"]),
        (('v', '<'), vec!["<"]),
        (('v', '>'), vec![">"]),
        //
        (('>', 'A'), vec!["^"]),
        (('>', '^'), vec!["^<", "<^"]),
        (('>', '<'), vec!["<<"]),
        (('>', 'v'), vec!["<"]),
    ])
}

fn numeric_keypad_rule() -> Rule {
    HashMap::from([
        //
        (('A', '0'), vec!["<"]),
        (('A', '1'), vec!["^<<"]),
        (('A', '2'), vec!["^<", "<^"]),
        (('A', '3'), vec!["^"]),
        (('A', '4'), vec!["^^<<"]),
        (('A', '5'), vec!["^^<", "<^^"]),
        (('A', '6'), vec!["^^"]),
        (('A', '7'), vec!["^^^<<"]),
        (('A', '8'), vec!["^^^<", "<^^^"]),
        (('A', '9'), vec!["^^^"]),
        //
        (('0', 'A'), vec![">"]),
        (('0', '1'), vec!["^<"]),
        (('0', '2'), vec!["^"]),
        (('0', '3'), vec!["^>", ">^"]),
        (('0', '4'), vec!["^^<"]),
        (('0', '5'), vec!["^^"]),
        (('0', '6'), vec!["^^>", ">^^"]),
        (('0', '7'), vec!["^^^<"]),
        (('0', '8'), vec!["^^^"]),
        (('0', '9'), vec!["^^^>", ">^^^"]),
        //
        (('1', 'A'), vec![">>v"]),
        (('1', '0'), vec![">v"]),
        (('1', '2'), vec![">"]),
        (('1', '3'), vec![">>>"]),
        (('1', '4'), vec!["^"]),
        (('1', '5'), vec!["^>", ">^"]),
        (('1', '6'), vec!["^>>", ">>^"]),
        (('1', '7'), vec!["^^"]),
        (('1', '8'), vec!["^^>", ">^^"]),
        (('1', '9'), vec!["^^>>", ">>^^"]),
        //
        (('2', 'A'), vec!["v>", ">v"]),
        (('2', '0'), vec!["v"]),
        (('2', '1'), vec!["<"]),
        (('2', '3'), vec![">"]),
        (('2', '4'), vec!["^<"]),
        (('2', '5'), vec!["^"]),
        (('2', '6'), vec!["^>", ">^"]),
        (('2', '7'), vec!["^^<", "<^^"]),
        (('2', '8'), vec!["^^"]),
        (('2', '9'), vec!["^^>", ">^^"]),
        //
        (('3', 'A'), vec!["v"]),
        (('3', '0'), vec!["v<", "<v"]),
        (('3', '1'), vec!["<<"]),
        (('3', '2'), vec!["<"]),
        (('3', '4'), vec!["^<<", "<<^"]),
        (('3', '5'), vec!["^<", "<^"]),
        (('3', '6'), vec!["^"]),
        (('3', '7'), vec!["^^<<", "<<^^"]),
        (('3', '8'), vec!["^^<", "<^^"]),
        (('3', '9'), vec!["^^"]),
        //
        (('4', 'A'), vec![">>vv"]),
        (('4', '0'), vec![">vv"]),
        (('4', '1'), vec!["v"]),
        (('4', '2'), vec!["v>", ">v"]),
        (('4', '3'), vec!["v>>", ">>v"]),
        (('4', '5'), vec![">"]),
        (('4', '6'), vec![">>"]),
        (('4', '7'), vec!["^"]),
        (('4', '8'), vec!["^>", ">^"]),
        (('4', '9'), vec!["^>>", ">>^"]),
        //
        (('5', 'A'), vec!["vv>", ">vv"]),
        (('5', '0'), vec!["vv"]),
        (('5', '1'), vec!["v<", "<v"]),
        (('5', '2'), vec!["v"]),
        (('5', '3'), vec!["v>", ">v"]),
        (('5', '4'), vec!["<"]),
        (('5', '6'), vec![">"]),
        (('5', '7'), vec!["^<", "<^"]),
        (('5', '8'), vec!["^"]),
        (('5', '9'), vec!["^>", ">^"]),
        //
        (('6', 'A'), vec!["vv"]),
        (('6', '0'), vec!["vv<", "<vv"]),
        (('6', '1'), vec!["v<<", "<<v"]),
        (('6', '2'), vec!["v<", "<v"]),
        (('6', '3'), vec!["v"]),
        (('6', '4'), vec!["<<"]),
        (('6', '5'), vec!["<"]),
        (('6', '7'), vec!["^<<", "<<^"]),
        (('6', '8'), vec!["^<", "<^"]),
        (('6', '9'), vec!["^"]),
        //
        (('7', 'A'), vec![">>vvv"]),
        (('7', '0'), vec![">vvv"]),
        (('7', '1'), vec!["vv"]),
        (('7', '2'), vec!["vv>", ">vv"]),
        (('7', '3'), vec!["vv>>", ">>vv"]),
        (('7', '4'), vec!["v"]),
        (('7', '5'), vec!["v>", ">v"]),
        (('7', '6'), vec!["v>>", ">>v"]),
        (('7', '8'), vec![">", ">"]),
        (('7', '9'), vec![">>"]),
        //
        (('8', 'A'), vec!["vvv>"]),
        (('8', '0'), vec!["vvv"]),
        (('8', '1'), vec!["vv<", "<vv"]),
        (('8', '2'), vec!["vv"]),
        (('8', '3'), vec!["vv>", ">vv"]),
        (('8', '4'), vec!["v<", "<v"]),
        (('8', '5'), vec!["v"]),
        (('8', '6'), vec!["v>", ">v"]),
        (('8', '7'), vec!["<"]),
        (('8', '9'), vec![">"]),
        //
        (('9', 'A'), vec!["vvv"]),
        (('9', '0'), vec!["vvv<", "<vvv"]),
        (('9', '1'), vec!["vv<<", "<<vv"]),
        (('9', '2'), vec!["vv<", "<vv"]),
        (('9', '3'), vec!["vv"]),
        (('9', '4'), vec!["v<<", "<<v"]),
        (('9', '5'), vec!["v<", "<v"]),
        (('9', '6'), vec!["v"]),
        (('9', '7'), vec!["<<"]),
        (('9', '8'), vec!["<"]),
    ])
}

fn expend(a: char, s: &str, rule: &Rule, prev: &str, ret: &mut Vec<String>) {
    if let Some(b) = s.chars().next() {
        for exp in rule.get(&(a, b)).unwrap_or(&vec![""]) {
            let expended: String = prev.to_string() + exp + "A";
            expend(b, &s[1..], rule, &expended, ret);
        }
    } else {
        ret.push(prev.to_string());
    }
}

fn parse_input(input: &str) -> Vec<&str> {
    input.trim().lines().collect()
}

pub fn part_one(input: &str) -> usize {
    let nkrule = numeric_keypad_rule();
    let dkrule = directional_keypad_rule();

    let ret = parse_input(input);

    ret.iter()
        .map(|r| {
            let mut ret1: Vec<String> = vec![r.to_string()];
            for i in 0..3 {
                let mut ret2: Vec<String> = Vec::new();
                let rule = if i == 0 { &nkrule } else { &dkrule };
                for item in ret1 {
                    expend('A', &item, &rule, "", &mut ret2);
                }
                ret1 = ret2;
            }
            let v = ret1.iter().map(|s| s.len()).min().unwrap();
            let w = r[..r.len() - 1].parse::<usize>().unwrap();
            v * w
        })
        .sum()
}

pub fn part_two(_input: &str) -> i32 {
    0
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::read_example;

    #[test]
    fn example() {
        let input = read_example(21);
        assert_eq!(part_one(&input), 126384);
        assert_eq!(part_two(&input), 0);
    }
}
